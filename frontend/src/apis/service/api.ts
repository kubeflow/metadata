/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * api/service.proto
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: version not set
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ApiCreateArtifactResponse
 */
export interface ApiCreateArtifactResponse {
    /**
     * Newly created artifact with id.
     * @type {MlMetadataArtifact}
     * @memberof ApiCreateArtifactResponse
     */
    artifact?: MlMetadataArtifact;
}

/**
 * 
 * @export
 * @interface ApiCreateArtifactTypeResponse
 */
export interface ApiCreateArtifactTypeResponse {
    /**
     * Newly created artifact type with id.
     * @type {MlMetadataArtifactType}
     * @memberof ApiCreateArtifactTypeResponse
     */
    artifact_type?: MlMetadataArtifactType;
}

/**
 * 
 * @export
 * @interface ApiCreateExecutionResponse
 */
export interface ApiCreateExecutionResponse {
    /**
     * Newly created execution with id.
     * @type {MlMetadataExecution}
     * @memberof ApiCreateExecutionResponse
     */
    execution?: MlMetadataExecution;
}

/**
 * 
 * @export
 * @interface ApiCreateExecutionTypeResponse
 */
export interface ApiCreateExecutionTypeResponse {
    /**
     * Newly created execution type with id.
     * @type {MlMetadataExecutionType}
     * @memberof ApiCreateExecutionTypeResponse
     */
    execution_type?: MlMetadataExecutionType;
}

/**
 * 
 * @export
 * @interface ApiGetArtifactResponse
 */
export interface ApiGetArtifactResponse {
    /**
     * 
     * @type {MlMetadataArtifact}
     * @memberof ApiGetArtifactResponse
     */
    artifact?: MlMetadataArtifact;
}

/**
 * 
 * @export
 * @interface ApiGetArtifactTypeResponse
 */
export interface ApiGetArtifactTypeResponse {
    /**
     * 
     * @type {MlMetadataArtifactType}
     * @memberof ApiGetArtifactTypeResponse
     */
    artifact_type?: MlMetadataArtifactType;
}

/**
 * 
 * @export
 * @interface ApiGetExecutionResponse
 */
export interface ApiGetExecutionResponse {
    /**
     * 
     * @type {MlMetadataExecution}
     * @memberof ApiGetExecutionResponse
     */
    execution?: MlMetadataExecution;
}

/**
 * 
 * @export
 * @interface ApiGetExecutionTypeResponse
 */
export interface ApiGetExecutionTypeResponse {
    /**
     * 
     * @type {MlMetadataExecutionType}
     * @memberof ApiGetExecutionTypeResponse
     */
    execution_type?: MlMetadataExecutionType;
}

/**
 * 
 * @export
 * @interface ApiListArtifactTypesResponse
 */
export interface ApiListArtifactTypesResponse {
    /**
     * 
     * @type {Array<MlMetadataArtifactType>}
     * @memberof ApiListArtifactTypesResponse
     */
    artifact_types?: Array<MlMetadataArtifactType>;
}

/**
 * 
 * @export
 * @interface ApiListArtifactsResponse
 */
export interface ApiListArtifactsResponse {
    /**
     * 
     * @type {Array<MlMetadataArtifact>}
     * @memberof ApiListArtifactsResponse
     */
    artifacts?: Array<MlMetadataArtifact>;
}

/**
 * 
 * @export
 * @interface ApiListExecutionTypesResponse
 */
export interface ApiListExecutionTypesResponse {
    /**
     * 
     * @type {Array<MlMetadataExecutionType>}
     * @memberof ApiListExecutionTypesResponse
     */
    execution_types?: Array<MlMetadataExecutionType>;
}

/**
 * 
 * @export
 * @interface ApiListExecutionsResponse
 */
export interface ApiListExecutionsResponse {
    /**
     * 
     * @type {Array<MlMetadataExecution>}
     * @memberof ApiListExecutionsResponse
     */
    executions?: Array<MlMetadataExecution>;
}

/**
 * Every ArtifactStruct is a member of this type.
 * @export
 * @interface MlMetadataAnyArtifactStructType
 */
export interface MlMetadataAnyArtifactStructType {
}

/**
 * 
 * @export
 * @interface MlMetadataArtifact
 */
export interface MlMetadataArtifact {
    /**
     * The id of the artifact.
     * @type {string}
     * @memberof MlMetadataArtifact
     */
    id?: string;
    /**
     * The id of an ArtifactType. Type must be specified when an artifact is created, and it cannot be changed.
     * @type {string}
     * @memberof MlMetadataArtifact
     */
    type_id?: string;
    /**
     * The uniform resource identifier of the physical artifact. May be empty if there is no physical artifact.
     * @type {string}
     * @memberof MlMetadataArtifact
     */
    uri?: string;
    /**
     * Properties of the artifact. Properties must be specified in the ArtifactType.
     * @type {{ [key: string]: MlMetadataValue; }}
     * @memberof MlMetadataArtifact
     */
    properties?: { [key: string]: MlMetadataValue; };
    /**
     * User provided custom properties which are not defined by its type.
     * @type {{ [key: string]: MlMetadataValue; }}
     * @memberof MlMetadataArtifact
     */
    custom_properties?: { [key: string]: MlMetadataValue; };
}

/**
 * The type of an ArtifactStruct. An artifact struct type represents an infinite set of artifact structs. It can specify the input or output type of an ExecutionType. See the more specific types referenced in the message for more details.
 * @export
 * @interface MlMetadataArtifactStructType
 */
export interface MlMetadataArtifactStructType {
    /**
     * 
     * @type {MlMetadataArtifactType}
     * @memberof MlMetadataArtifactStructType
     */
    simple?: MlMetadataArtifactType;
    /**
     * 
     * @type {MlMetadataUnionArtifactStructType}
     * @memberof MlMetadataArtifactStructType
     */
    union_type?: MlMetadataUnionArtifactStructType;
    /**
     * 
     * @type {MlMetadataIntersectionArtifactStructType}
     * @memberof MlMetadataArtifactStructType
     */
    intersection?: MlMetadataIntersectionArtifactStructType;
    /**
     * 
     * @type {MlMetadataListArtifactStructType}
     * @memberof MlMetadataArtifactStructType
     */
    list?: MlMetadataListArtifactStructType;
    /**
     * 
     * @type {MlMetadataNoneArtifactStructType}
     * @memberof MlMetadataArtifactStructType
     */
    none?: MlMetadataNoneArtifactStructType;
    /**
     * 
     * @type {MlMetadataAnyArtifactStructType}
     * @memberof MlMetadataArtifactStructType
     */
    any?: MlMetadataAnyArtifactStructType;
    /**
     * 
     * @type {MlMetadataTupleArtifactStructType}
     * @memberof MlMetadataArtifactStructType
     */
    tuple?: MlMetadataTupleArtifactStructType;
    /**
     * 
     * @type {MlMetadataDictArtifactStructType}
     * @memberof MlMetadataArtifactStructType
     */
    dict?: MlMetadataDictArtifactStructType;
}

/**
 * 
 * @export
 * @interface MlMetadataArtifactType
 */
export interface MlMetadataArtifactType {
    /**
     * The id of the type. 1-1 relationship between type names and IDs.
     * @type {string}
     * @memberof MlMetadataArtifactType
     */
    id?: string;
    /**
     * The name of the type.
     * @type {string}
     * @memberof MlMetadataArtifactType
     */
    name?: string;
    /**
     * The schema of the type. Properties are always optional in the artifact. Properties of an artifact type can be expanded but not contracted (i.e., you can add columns but not remove them).
     * @type {{ [key: string]: MlMetadataPropertyType; }}
     * @memberof MlMetadataArtifactType
     */
    properties?: { [key: string]: MlMetadataPropertyType; };
}

/**
 * 
 * @export
 * @interface MlMetadataDictArtifactStructType
 */
export interface MlMetadataDictArtifactStructType {
    /**
     * Underlying properties for the type.
     * @type {{ [key: string]: MlMetadataArtifactStructType; }}
     * @memberof MlMetadataDictArtifactStructType
     */
    properties?: { [key: string]: MlMetadataArtifactStructType; };
    /**
     * If true, then if properties[\"foo\"] can be None, then that key is not required.
     * @type {boolean}
     * @memberof MlMetadataDictArtifactStructType
     */
    none_type_not_required?: boolean;
    /**
     * Extra keys are allowed that are not specified in properties. These keys must have the type specified below. If this is not specified, then extra properties are not allowed.
     * @type {MlMetadataArtifactStructType}
     * @memberof MlMetadataDictArtifactStructType
     */
    extra_properties_type?: MlMetadataArtifactStructType;
}

/**
 * 
 * @export
 * @interface MlMetadataExecution
 */
export interface MlMetadataExecution {
    /**
     * The id of the execution.
     * @type {string}
     * @memberof MlMetadataExecution
     */
    id?: string;
    /**
     * The id of an ExecutionType. The ExecutionType must be specified and cannot be changed.
     * @type {string}
     * @memberof MlMetadataExecution
     */
    type_id?: string;
    /**
     * The last known state of an execution.
     * @type {MlMetadataExecutionState}
     * @memberof MlMetadataExecution
     */
    last_known_state?: MlMetadataExecutionState;
    /**
     * Properties of the Execution. Properties must be specified in the ExecutionType.
     * @type {{ [key: string]: MlMetadataValue; }}
     * @memberof MlMetadataExecution
     */
    properties?: { [key: string]: MlMetadataValue; };
    /**
     * User provided custom properties which are not defined by its type.
     * @type {{ [key: string]: MlMetadataValue; }}
     * @memberof MlMetadataExecution
     */
    custom_properties?: { [key: string]: MlMetadataValue; };
}

/**
 * TODO(martinz): consider adding INVALIDATED as a state.
 * @export
 * @enum {string}
 */
export enum MlMetadataExecutionState {
    UNKNOWN = <any> 'UNKNOWN',
    NEW = <any> 'NEW',
    RUNNING = <any> 'RUNNING',
    COMPLETE = <any> 'COMPLETE',
    FAILED = <any> 'FAILED'
}

/**
 * 
 * @export
 * @interface MlMetadataExecutionType
 */
export interface MlMetadataExecutionType {
    /**
     * The id of the type. 1-1 relationship between type names and IDs.
     * @type {string}
     * @memberof MlMetadataExecutionType
     */
    id?: string;
    /**
     * The name of the type.
     * @type {string}
     * @memberof MlMetadataExecutionType
     */
    name?: string;
    /**
     * The schema of the type. Properties are always optional in the execution.
     * @type {{ [key: string]: MlMetadataPropertyType; }}
     * @memberof MlMetadataExecutionType
     */
    properties?: { [key: string]: MlMetadataPropertyType; };
    /**
     * The ArtifactStructType of the input. For example: {     \"dict\":{        \"properties\":{          \"schema\":{            \"union_type\":{              \"none\":{},              \"simple\":{...schema type...}             },          },          \"data\":{            \"simple\":{...data_type...}          }       }     } } That would be an optional schema field with a required data field.
     * @type {MlMetadataArtifactStructType}
     * @memberof MlMetadataExecutionType
     */
    input_type?: MlMetadataArtifactStructType;
    /**
     * 
     * @type {MlMetadataArtifactStructType}
     * @memberof MlMetadataExecutionType
     */
    output_type?: MlMetadataArtifactStructType;
}

/**
 * A member of this type must satisfy all constraints. This primarily useful not as an end-user type, but something calculated as an intermediate type in the system.  For example, suppose you have a method: def infer_my_input_type(a): # try to infer the input type of this method.   use_in_method_x(a) # with input type x_input   use_in_method_y(a) # with input type y_input  Given this information, you know that infer_my_input_type has type {\"intersection\":{\"constraints\":[x_input, y_input]}}.  IntersectionArtifactStructType intersection_type = {\"constraints\":[     {\"dict\":{\"properties\":{\"schema\":{\"any\":{}}},              \"extra_properties\":{\"any\":{}}}},     {\"dict\":{\"properties\":{\"data\":{\"any\":{}}},              \"extra_properties\":{\"any\":{}}}}]} Since the first constraint requires the dictionary to have a schema property, and the second constraint requires it to have a data property, this is equivalent to: ArtifactStructType other_type =      {\"dict\":{\"properties\":{\"schema\":{\"any\":{}},\"data\":{\"any\":{}}}},       \"extra_properties\":{\"any\":{}}}
 * @export
 * @interface MlMetadataIntersectionArtifactStructType
 */
export interface MlMetadataIntersectionArtifactStructType {
    /**
     * 
     * @type {Array<MlMetadataArtifactStructType>}
     * @memberof MlMetadataIntersectionArtifactStructType
     */
    constraints?: Array<MlMetadataArtifactStructType>;
}

/**
 * Represents an ArtifactStruct list type with homogeneous elements.
 * @export
 * @interface MlMetadataListArtifactStructType
 */
export interface MlMetadataListArtifactStructType {
    /**
     * Every entry in the list must be of this type. Note: if this type is Any, then the list can have arbitrary elements.
     * @type {MlMetadataArtifactStructType}
     * @memberof MlMetadataListArtifactStructType
     */
    element?: MlMetadataArtifactStructType;
}

/**
 * 
 * @export
 * @interface MlMetadataNoneArtifactStructType
 */
export interface MlMetadataNoneArtifactStructType {
}

/**
 * TODO(martinz): consider moving this inside some message, to avoid having literals directly in apo package.
 * @export
 * @enum {string}
 */
export enum MlMetadataPropertyType {
    UNKNOWN = <any> 'UNKNOWN',
    INT = <any> 'INT',
    DOUBLE = <any> 'DOUBLE',
    STRING = <any> 'STRING'
}

/**
 * An ordered list of heterogenous artifact structs. The length of the list is fixed. Each position in the list can have a different type.
 * @export
 * @interface MlMetadataTupleArtifactStructType
 */
export interface MlMetadataTupleArtifactStructType {
    /**
     * 
     * @type {Array<MlMetadataArtifactStructType>}
     * @memberof MlMetadataTupleArtifactStructType
     */
    elements?: Array<MlMetadataArtifactStructType>;
}

/**
 * Represents a union of types.
 * @export
 * @interface MlMetadataUnionArtifactStructType
 */
export interface MlMetadataUnionArtifactStructType {
    /**
     * An artifact struct matches this type if it matches any of the candidates. If candidates is empty, this is a bottom type (matches no artifacts).
     * @type {Array<MlMetadataArtifactStructType>}
     * @memberof MlMetadataUnionArtifactStructType
     */
    candidates?: Array<MlMetadataArtifactStructType>;
}

/**
 * A value in properties.
 * @export
 * @interface MlMetadataValue
 */
export interface MlMetadataValue {
    /**
     * 
     * @type {string}
     * @memberof MlMetadataValue
     */
    int_value?: string;
    /**
     * 
     * @type {number}
     * @memberof MlMetadataValue
     */
    double_value?: number;
    /**
     * 
     * @type {string}
     * @memberof MlMetadataValue
     */
    string_value?: string;
}


/**
 * MetadataServiceApi - fetch parameter creator
 * @export
 */
export const MetadataServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary NOTE: The order of the following RPC methods affects the order of matching a particular HTTP path. So put a more specific path pattern before a generic one. For example, GET /api/v1alpha1/{parent}/artifacts should appear before GET /api/v1alpha1/{name} to be possibly matched.
         * @param {string} parent Creates the specified artifact as an instance of ArtifactType with this fully qualified name. |parent| takes the form &#x60;artifact_types/{namespace}/{name&gt;}&#x60;.
         * @param {MlMetadataArtifact} body The Artifact to create. Note that Artifact.type_id is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(parent: string, body: MlMetadataArtifact, options: any = {}): FetchArgs {
            // verify required parameter 'parent' is not null or undefined
            if (parent === null || parent === undefined) {
                throw new RequiredError('parent','Required parameter parent was null or undefined when calling createArtifact.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createArtifact.');
            }
            const localVarPath = `/api/v1alpha1/{parent}/artifacts`
                .replace(`{${"parent"}}`, encodeURIComponent(String(parent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MlMetadataArtifact" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MlMetadataArtifactType} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactType(body: MlMetadataArtifactType, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createArtifactType.');
            }
            const localVarPath = `/api/v1alpha1/artifact_types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MlMetadataArtifactType" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} parent Creates the specified artifact as an instance of ExecutionType with this fully qualified name. |parent| takes the form &#x60;execution_types/{namespace}/{name&gt;}&#x60;.
         * @param {MlMetadataExecution} body The Execution to create. Note that Execution.type_id is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExecution(parent: string, body: MlMetadataExecution, options: any = {}): FetchArgs {
            // verify required parameter 'parent' is not null or undefined
            if (parent === null || parent === undefined) {
                throw new RequiredError('parent','Required parameter parent was null or undefined when calling createExecution.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createExecution.');
            }
            const localVarPath = `/api/v1alpha1/{parent}/executions`
                .replace(`{${"parent"}}`, encodeURIComponent(String(parent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MlMetadataExecution" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MlMetadataExecutionType} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExecutionType(body: MlMetadataExecutionType, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createExecutionType.');
            }
            const localVarPath = `/api/v1alpha1/execution_types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MlMetadataExecutionType" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExecutionType(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteExecutionType.');
            }
            const localVarPath = `/api/v1alpha1/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionType(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getExecutionType.');
            }
            const localVarPath = `/api/v1alpha1/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactTypes(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1alpha1/artifact_types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling listArtifacts.');
            }
            const localVarPath = `/api/v1alpha1/{name}/artifacts`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts2(name?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1alpha1/artifacts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutionTypes(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1alpha1/execution_types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutions(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling listExecutions.');
            }
            const localVarPath = `/api/v1alpha1/{name}/executions`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutions2(name?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1alpha1/executions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataServiceApi - functional programming interface
 * @export
 */
export const MetadataServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary NOTE: The order of the following RPC methods affects the order of matching a particular HTTP path. So put a more specific path pattern before a generic one. For example, GET /api/v1alpha1/{parent}/artifacts should appear before GET /api/v1alpha1/{name} to be possibly matched.
         * @param {string} parent Creates the specified artifact as an instance of ArtifactType with this fully qualified name. |parent| takes the form &#x60;artifact_types/{namespace}/{name&gt;}&#x60;.
         * @param {MlMetadataArtifact} body The Artifact to create. Note that Artifact.type_id is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(parent: string, body: MlMetadataArtifact, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCreateArtifactResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).createArtifact(parent, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {MlMetadataArtifactType} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactType(body: MlMetadataArtifactType, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCreateArtifactTypeResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).createArtifactType(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} parent Creates the specified artifact as an instance of ExecutionType with this fully qualified name. |parent| takes the form &#x60;execution_types/{namespace}/{name&gt;}&#x60;.
         * @param {MlMetadataExecution} body The Execution to create. Note that Execution.type_id is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExecution(parent: string, body: MlMetadataExecution, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCreateExecutionResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).createExecution(parent, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {MlMetadataExecutionType} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExecutionType(body: MlMetadataExecutionType, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCreateExecutionTypeResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).createExecutionType(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExecutionType(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).deleteExecutionType(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionType(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiGetExecutionTypeResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).getExecutionType(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactTypes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiListArtifactTypesResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).listArtifactTypes(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiListArtifactsResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).listArtifacts(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts2(name?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiListArtifactsResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).listArtifacts2(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutionTypes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiListExecutionTypesResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).listExecutionTypes(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutions(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiListExecutionsResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).listExecutions(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutions2(name?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiListExecutionsResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).listExecutions2(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MetadataServiceApi - factory interface
 * @export
 */
export const MetadataServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary NOTE: The order of the following RPC methods affects the order of matching a particular HTTP path. So put a more specific path pattern before a generic one. For example, GET /api/v1alpha1/{parent}/artifacts should appear before GET /api/v1alpha1/{name} to be possibly matched.
         * @param {string} parent Creates the specified artifact as an instance of ArtifactType with this fully qualified name. |parent| takes the form &#x60;artifact_types/{namespace}/{name&gt;}&#x60;.
         * @param {MlMetadataArtifact} body The Artifact to create. Note that Artifact.type_id is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(parent: string, body: MlMetadataArtifact, options?: any) {
            return MetadataServiceApiFp(configuration).createArtifact(parent, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {MlMetadataArtifactType} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactType(body: MlMetadataArtifactType, options?: any) {
            return MetadataServiceApiFp(configuration).createArtifactType(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} parent Creates the specified artifact as an instance of ExecutionType with this fully qualified name. |parent| takes the form &#x60;execution_types/{namespace}/{name&gt;}&#x60;.
         * @param {MlMetadataExecution} body The Execution to create. Note that Execution.type_id is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExecution(parent: string, body: MlMetadataExecution, options?: any) {
            return MetadataServiceApiFp(configuration).createExecution(parent, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {MlMetadataExecutionType} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExecutionType(body: MlMetadataExecutionType, options?: any) {
            return MetadataServiceApiFp(configuration).createExecutionType(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExecutionType(name: string, options?: any) {
            return MetadataServiceApiFp(configuration).deleteExecutionType(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionType(name: string, options?: any) {
            return MetadataServiceApiFp(configuration).getExecutionType(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactTypes(options?: any) {
            return MetadataServiceApiFp(configuration).listArtifactTypes(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts(name: string, options?: any) {
            return MetadataServiceApiFp(configuration).listArtifacts(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts2(name?: string, options?: any) {
            return MetadataServiceApiFp(configuration).listArtifacts2(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutionTypes(options?: any) {
            return MetadataServiceApiFp(configuration).listExecutionTypes(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutions(name: string, options?: any) {
            return MetadataServiceApiFp(configuration).listExecutions(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutions2(name?: string, options?: any) {
            return MetadataServiceApiFp(configuration).listExecutions2(name, options)(fetch, basePath);
        },
    };
};

/**
 * MetadataServiceApi - object-oriented interface
 * @export
 * @class MetadataServiceApi
 * @extends {BaseAPI}
 */
export class MetadataServiceApi extends BaseAPI {
    /**
     * 
     * @summary NOTE: The order of the following RPC methods affects the order of matching a particular HTTP path. So put a more specific path pattern before a generic one. For example, GET /api/v1alpha1/{parent}/artifacts should appear before GET /api/v1alpha1/{name} to be possibly matched.
     * @param {string} parent Creates the specified artifact as an instance of ArtifactType with this fully qualified name. |parent| takes the form &#x60;artifact_types/{namespace}/{name&gt;}&#x60;.
     * @param {MlMetadataArtifact} body The Artifact to create. Note that Artifact.type_id is ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public createArtifact(parent: string, body: MlMetadataArtifact, options?: any) {
        return MetadataServiceApiFp(this.configuration).createArtifact(parent, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {MlMetadataArtifactType} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public createArtifactType(body: MlMetadataArtifactType, options?: any) {
        return MetadataServiceApiFp(this.configuration).createArtifactType(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} parent Creates the specified artifact as an instance of ExecutionType with this fully qualified name. |parent| takes the form &#x60;execution_types/{namespace}/{name&gt;}&#x60;.
     * @param {MlMetadataExecution} body The Execution to create. Note that Execution.type_id is ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public createExecution(parent: string, body: MlMetadataExecution, options?: any) {
        return MetadataServiceApiFp(this.configuration).createExecution(parent, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {MlMetadataExecutionType} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public createExecutionType(body: MlMetadataExecutionType, options?: any) {
        return MetadataServiceApiFp(this.configuration).createExecutionType(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public deleteExecutionType(name: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).deleteExecutionType(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public getExecutionType(name: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).getExecutionType(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public listArtifactTypes(options?: any) {
        return MetadataServiceApiFp(this.configuration).listArtifactTypes(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public listArtifacts(name: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).listArtifacts(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public listArtifacts2(name?: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).listArtifacts2(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public listExecutionTypes(options?: any) {
        return MetadataServiceApiFp(this.configuration).listExecutionTypes(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public listExecutions(name: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).listExecutions(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public listExecutions2(name?: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).listExecutions2(name, options)(this.fetch, this.basePath);
    }

}

