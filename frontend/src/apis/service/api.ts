/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * api/service.proto
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: version not set
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ApiCreateArtifactResponse
 */
export interface ApiCreateArtifactResponse {
    /**
     * Newly created artifact with id.
     * @type {MlMetadataArtifact}
     * @memberof ApiCreateArtifactResponse
     */
    artifact?: MlMetadataArtifact;
}

/**
 * 
 * @export
 * @interface ApiCreateArtifactTypeResponse
 */
export interface ApiCreateArtifactTypeResponse {
    /**
     * Newly created artifact type with id.
     * @type {MlMetadataArtifactType}
     * @memberof ApiCreateArtifactTypeResponse
     */
    artifact_type?: MlMetadataArtifactType;
}

/**
 * 
 * @export
 * @interface ApiCreateExecutionResponse
 */
export interface ApiCreateExecutionResponse {
    /**
     * Newly created execution with id.
     * @type {MlMetadataExecution}
     * @memberof ApiCreateExecutionResponse
     */
    execution?: MlMetadataExecution;
}

/**
 * 
 * @export
 * @interface ApiCreateExecutionTypeResponse
 */
export interface ApiCreateExecutionTypeResponse {
    /**
     * Newly created execution type with id.
     * @type {MlMetadataExecutionType}
     * @memberof ApiCreateExecutionTypeResponse
     */
    execution_type?: MlMetadataExecutionType;
}

/**
 * 
 * @export
 * @interface ApiGetArtifactResponse
 */
export interface ApiGetArtifactResponse {
    /**
     * 
     * @type {MlMetadataArtifact}
     * @memberof ApiGetArtifactResponse
     */
    artifact?: MlMetadataArtifact;
}

/**
 * 
 * @export
 * @interface ApiGetArtifactTypeResponse
 */
export interface ApiGetArtifactTypeResponse {
    /**
     * 
     * @type {MlMetadataArtifactType}
     * @memberof ApiGetArtifactTypeResponse
     */
    artifact_type?: MlMetadataArtifactType;
}

/**
 * 
 * @export
 * @interface ApiGetExecutionResponse
 */
export interface ApiGetExecutionResponse {
    /**
     * 
     * @type {MlMetadataExecution}
     * @memberof ApiGetExecutionResponse
     */
    execution?: MlMetadataExecution;
}

/**
 * 
 * @export
 * @interface ApiGetExecutionTypeResponse
 */
export interface ApiGetExecutionTypeResponse {
    /**
     * 
     * @type {MlMetadataExecutionType}
     * @memberof ApiGetExecutionTypeResponse
     */
    execution_type?: MlMetadataExecutionType;
}

/**
 * 
 * @export
 * @interface ApiListArtifactTypesResponse
 */
export interface ApiListArtifactTypesResponse {
    /**
     * 
     * @type {Array<MlMetadataArtifactType>}
     * @memberof ApiListArtifactTypesResponse
     */
    artifact_types?: Array<MlMetadataArtifactType>;
}

/**
 * 
 * @export
 * @interface ApiListArtifactsResponse
 */
export interface ApiListArtifactsResponse {
    /**
     * 
     * @type {Array<MlMetadataArtifact>}
     * @memberof ApiListArtifactsResponse
     */
    artifacts?: Array<MlMetadataArtifact>;
}

/**
 * 
 * @export
 * @interface ApiListEventsResponse
 */
export interface ApiListEventsResponse {
    /**
     * 
     * @type {Array<MlMetadataEvent>}
     * @memberof ApiListEventsResponse
     */
    events?: Array<MlMetadataEvent>;
    /**
     * 
     * @type {{ [key: string]: MlMetadataArtifact; }}
     * @memberof ApiListEventsResponse
     */
    artifacts?: { [key: string]: MlMetadataArtifact; };
    /**
     * 
     * @type {{ [key: string]: MlMetadataExecution; }}
     * @memberof ApiListEventsResponse
     */
    executions?: { [key: string]: MlMetadataExecution; };
}

/**
 * 
 * @export
 * @interface ApiListExecutionTypesResponse
 */
export interface ApiListExecutionTypesResponse {
    /**
     * 
     * @type {Array<MlMetadataExecutionType>}
     * @memberof ApiListExecutionTypesResponse
     */
    execution_types?: Array<MlMetadataExecutionType>;
}

/**
 * 
 * @export
 * @interface ApiListExecutionsResponse
 */
export interface ApiListExecutionsResponse {
    /**
     * 
     * @type {Array<MlMetadataExecution>}
     * @memberof ApiListExecutionsResponse
     */
    executions?: Array<MlMetadataExecution>;
}

/**
 * A simple path (e.g. {step{key:\"foo\"}}) can name an artifact in the context of an execution.
 * @export
 * @interface EventPath
 */
export interface EventPath {
    /**
     * A simple path (e.g. {step{key:\"foo\"}}) can name an artifact in the context of an execution.
     * @type {Array<PathStep>}
     * @memberof EventPath
     */
    steps?: Array<PathStep>;
}

/**
 * Every ArtifactStruct is a member of this type.
 * @export
 * @interface MlMetadataAnyArtifactStructType
 */
export interface MlMetadataAnyArtifactStructType {
}

/**
 * 
 * @export
 * @interface MlMetadataArtifact
 */
export interface MlMetadataArtifact {
    /**
     * The id of the artifact.
     * @type {string}
     * @memberof MlMetadataArtifact
     */
    id?: string;
    /**
     * The id of an ArtifactType. Type must be specified when an artifact is created, and it cannot be changed.
     * @type {string}
     * @memberof MlMetadataArtifact
     */
    type_id?: string;
    /**
     * The uniform resource identifier of the physical artifact. May be empty if there is no physical artifact.
     * @type {string}
     * @memberof MlMetadataArtifact
     */
    uri?: string;
    /**
     * Properties of the artifact. Properties must be specified in the ArtifactType.
     * @type {{ [key: string]: MlMetadataValue; }}
     * @memberof MlMetadataArtifact
     */
    properties?: { [key: string]: MlMetadataValue; };
    /**
     * User provided custom properties which are not defined by its type.
     * @type {{ [key: string]: MlMetadataValue; }}
     * @memberof MlMetadataArtifact
     */
    custom_properties?: { [key: string]: MlMetadataValue; };
}

/**
 * The type of an ArtifactStruct. An artifact struct type represents an infinite set of artifact structs. It can specify the input or output type of an ExecutionType. See the more specific types referenced in the message for more details.
 * @export
 * @interface MlMetadataArtifactStructType
 */
export interface MlMetadataArtifactStructType {
    /**
     * 
     * @type {MlMetadataArtifactType}
     * @memberof MlMetadataArtifactStructType
     */
    simple?: MlMetadataArtifactType;
    /**
     * 
     * @type {MlMetadataUnionArtifactStructType}
     * @memberof MlMetadataArtifactStructType
     */
    union_type?: MlMetadataUnionArtifactStructType;
    /**
     * 
     * @type {MlMetadataIntersectionArtifactStructType}
     * @memberof MlMetadataArtifactStructType
     */
    intersection?: MlMetadataIntersectionArtifactStructType;
    /**
     * 
     * @type {MlMetadataListArtifactStructType}
     * @memberof MlMetadataArtifactStructType
     */
    list?: MlMetadataListArtifactStructType;
    /**
     * 
     * @type {MlMetadataNoneArtifactStructType}
     * @memberof MlMetadataArtifactStructType
     */
    none?: MlMetadataNoneArtifactStructType;
    /**
     * 
     * @type {MlMetadataAnyArtifactStructType}
     * @memberof MlMetadataArtifactStructType
     */
    any?: MlMetadataAnyArtifactStructType;
    /**
     * 
     * @type {MlMetadataTupleArtifactStructType}
     * @memberof MlMetadataArtifactStructType
     */
    tuple?: MlMetadataTupleArtifactStructType;
    /**
     * 
     * @type {MlMetadataDictArtifactStructType}
     * @memberof MlMetadataArtifactStructType
     */
    dict?: MlMetadataDictArtifactStructType;
}

/**
 * 
 * @export
 * @interface MlMetadataArtifactType
 */
export interface MlMetadataArtifactType {
    /**
     * The id of the type. 1-1 relationship between type names and IDs.
     * @type {string}
     * @memberof MlMetadataArtifactType
     */
    id?: string;
    /**
     * The name of the type.
     * @type {string}
     * @memberof MlMetadataArtifactType
     */
    name?: string;
    /**
     * The schema of the type. Properties are always optional in the artifact. Properties of an artifact type can be expanded but not contracted (i.e., you can add columns but not remove them).
     * @type {{ [key: string]: MlMetadataPropertyType; }}
     * @memberof MlMetadataArtifactType
     */
    properties?: { [key: string]: MlMetadataPropertyType; };
}

/**
 * 
 * @export
 * @interface MlMetadataDictArtifactStructType
 */
export interface MlMetadataDictArtifactStructType {
    /**
     * Underlying properties for the type.
     * @type {{ [key: string]: MlMetadataArtifactStructType; }}
     * @memberof MlMetadataDictArtifactStructType
     */
    properties?: { [key: string]: MlMetadataArtifactStructType; };
    /**
     * If true, then if properties[\"foo\"] can be None, then that key is not required.
     * @type {boolean}
     * @memberof MlMetadataDictArtifactStructType
     */
    none_type_not_required?: boolean;
    /**
     * Extra keys are allowed that are not specified in properties. These keys must have the type specified below. If this is not specified, then extra properties are not allowed.
     * @type {MlMetadataArtifactStructType}
     * @memberof MlMetadataDictArtifactStructType
     */
    extra_properties_type?: MlMetadataArtifactStructType;
}

/**
 * An event represents a relationship between an artifact ID and an execution. There are four kinds of events, relating to both input and output, as well as declared versus undeclared. For example, the DECLARED_INPUT events are part of the signature of an execution. For example, consider: my_execution({\"data\":[3,7],\"schema\":8}) Where 3, 7, and 8 are artifact_ids. Assuming execution_id is 12, this becomes: {artifact_id:3, execution_id: 12, type:DECLARED_INPUT,  path:{step:[{\"key\":\"data\"},{\"index\":0}]}} {artifact_id:7, execution_id: 12, type:DECLARED_INPUT,  path:{step:[{\"key\":\"data\"},{\"index\":1}]}} {artifact_id:8, execution_id: 12, type:DECLARED_INPUT,  path:{step:[{\"key\":\"schema\"}]}} The INPUT is an artifact actually read by the execution. The OUTPUT is an artifact actually written by the execution. The DECLARED_OUTPUT are the artifacts that are the \"official\" output. For example, the trainer may output multiple caches of the parameters (as OUTPUT objects), but then finally write the SavedModel as a DECLARED_OUTPUT. TODO(martinz): add a type for Event, similar to ArtifactType.
 * @export
 * @interface MlMetadataEvent
 */
export interface MlMetadataEvent {
    /**
     * The artifact id is required for an event, and should refer to an existing artifact.
     * @type {string}
     * @memberof MlMetadataEvent
     */
    artifact_id?: string;
    /**
     * The execution_id is required for an event, and should refer to an existing execution.
     * @type {string}
     * @memberof MlMetadataEvent
     */
    execution_id?: string;
    /**
     * The path in an artifact struct, or the name of an artifact.
     * @type {EventPath}
     * @memberof MlMetadataEvent
     */
    path?: EventPath;
    /**
     * The type of an event.
     * @type {MlMetadataEventType}
     * @memberof MlMetadataEvent
     */
    type?: MlMetadataEventType;
    /**
     * 
     * @type {string}
     * @memberof MlMetadataEvent
     */
    milliseconds_since_epoch?: string;
}

/**
 * Events distinguish between an artifact that is written by the execution (possibly as a cache), versus artifacts that are part of the declared output of the Execution. For more information on what DECLARED_ means, see the comment on the message.
 * @export
 * @enum {string}
 */
export enum MlMetadataEventType {
    UNKNOWN = <any> 'UNKNOWN',
    DECLAREDOUTPUT = <any> 'DECLARED_OUTPUT',
    DECLAREDINPUT = <any> 'DECLARED_INPUT',
    INPUT = <any> 'INPUT',
    OUTPUT = <any> 'OUTPUT'
}

/**
 * 
 * @export
 * @interface MlMetadataExecution
 */
export interface MlMetadataExecution {
    /**
     * The id of the execution.
     * @type {string}
     * @memberof MlMetadataExecution
     */
    id?: string;
    /**
     * The id of an ExecutionType. The ExecutionType must be specified and cannot be changed.
     * @type {string}
     * @memberof MlMetadataExecution
     */
    type_id?: string;
    /**
     * The last known state of an execution.
     * @type {MlMetadataExecutionState}
     * @memberof MlMetadataExecution
     */
    last_known_state?: MlMetadataExecutionState;
    /**
     * Properties of the Execution. Properties must be specified in the ExecutionType.
     * @type {{ [key: string]: MlMetadataValue; }}
     * @memberof MlMetadataExecution
     */
    properties?: { [key: string]: MlMetadataValue; };
    /**
     * User provided custom properties which are not defined by its type.
     * @type {{ [key: string]: MlMetadataValue; }}
     * @memberof MlMetadataExecution
     */
    custom_properties?: { [key: string]: MlMetadataValue; };
}

/**
 * TODO(martinz): consider adding INVALIDATED as a state.
 * @export
 * @enum {string}
 */
export enum MlMetadataExecutionState {
    UNKNOWN = <any> 'UNKNOWN',
    NEW = <any> 'NEW',
    RUNNING = <any> 'RUNNING',
    COMPLETE = <any> 'COMPLETE',
    FAILED = <any> 'FAILED'
}

/**
 * 
 * @export
 * @interface MlMetadataExecutionType
 */
export interface MlMetadataExecutionType {
    /**
     * The id of the type. 1-1 relationship between type names and IDs.
     * @type {string}
     * @memberof MlMetadataExecutionType
     */
    id?: string;
    /**
     * The name of the type.
     * @type {string}
     * @memberof MlMetadataExecutionType
     */
    name?: string;
    /**
     * The schema of the type. Properties are always optional in the execution.
     * @type {{ [key: string]: MlMetadataPropertyType; }}
     * @memberof MlMetadataExecutionType
     */
    properties?: { [key: string]: MlMetadataPropertyType; };
    /**
     * The ArtifactStructType of the input. For example: {     \"dict\":{        \"properties\":{          \"schema\":{            \"union_type\":{              \"none\":{},              \"simple\":{...schema type...}             },          },          \"data\":{            \"simple\":{...data_type...}          }       }     } } That would be an optional schema field with a required data field.
     * @type {MlMetadataArtifactStructType}
     * @memberof MlMetadataExecutionType
     */
    input_type?: MlMetadataArtifactStructType;
    /**
     * 
     * @type {MlMetadataArtifactStructType}
     * @memberof MlMetadataExecutionType
     */
    output_type?: MlMetadataArtifactStructType;
}

/**
 * A member of this type must satisfy all constraints. This primarily useful not as an end-user type, but something calculated as an intermediate type in the system.  For example, suppose you have a method: def infer_my_input_type(a): # try to infer the input type of this method.   use_in_method_x(a) # with input type x_input   use_in_method_y(a) # with input type y_input  Given this information, you know that infer_my_input_type has type {\"intersection\":{\"constraints\":[x_input, y_input]}}.  IntersectionArtifactStructType intersection_type = {\"constraints\":[     {\"dict\":{\"properties\":{\"schema\":{\"any\":{}}},              \"extra_properties\":{\"any\":{}}}},     {\"dict\":{\"properties\":{\"data\":{\"any\":{}}},              \"extra_properties\":{\"any\":{}}}}]} Since the first constraint requires the dictionary to have a schema property, and the second constraint requires it to have a data property, this is equivalent to: ArtifactStructType other_type =      {\"dict\":{\"properties\":{\"schema\":{\"any\":{}},\"data\":{\"any\":{}}}},       \"extra_properties\":{\"any\":{}}}
 * @export
 * @interface MlMetadataIntersectionArtifactStructType
 */
export interface MlMetadataIntersectionArtifactStructType {
    /**
     * 
     * @type {Array<MlMetadataArtifactStructType>}
     * @memberof MlMetadataIntersectionArtifactStructType
     */
    constraints?: Array<MlMetadataArtifactStructType>;
}

/**
 * Represents an ArtifactStruct list type with homogeneous elements.
 * @export
 * @interface MlMetadataListArtifactStructType
 */
export interface MlMetadataListArtifactStructType {
    /**
     * Every entry in the list must be of this type. Note: if this type is Any, then the list can have arbitrary elements.
     * @type {MlMetadataArtifactStructType}
     * @memberof MlMetadataListArtifactStructType
     */
    element?: MlMetadataArtifactStructType;
}

/**
 * 
 * @export
 * @interface MlMetadataNoneArtifactStructType
 */
export interface MlMetadataNoneArtifactStructType {
}

/**
 * TODO(martinz): consider moving this inside some message, to avoid having literals directly in apo package.
 * @export
 * @enum {string}
 */
export enum MlMetadataPropertyType {
    UNKNOWN = <any> 'UNKNOWN',
    INT = <any> 'INT',
    DOUBLE = <any> 'DOUBLE',
    STRING = <any> 'STRING'
}

/**
 * An ordered list of heterogenous artifact structs. The length of the list is fixed. Each position in the list can have a different type.
 * @export
 * @interface MlMetadataTupleArtifactStructType
 */
export interface MlMetadataTupleArtifactStructType {
    /**
     * 
     * @type {Array<MlMetadataArtifactStructType>}
     * @memberof MlMetadataTupleArtifactStructType
     */
    elements?: Array<MlMetadataArtifactStructType>;
}

/**
 * Represents a union of types.
 * @export
 * @interface MlMetadataUnionArtifactStructType
 */
export interface MlMetadataUnionArtifactStructType {
    /**
     * An artifact struct matches this type if it matches any of the candidates. If candidates is empty, this is a bottom type (matches no artifacts).
     * @type {Array<MlMetadataArtifactStructType>}
     * @memberof MlMetadataUnionArtifactStructType
     */
    candidates?: Array<MlMetadataArtifactStructType>;
}

/**
 * A value in properties.
 * @export
 * @interface MlMetadataValue
 */
export interface MlMetadataValue {
    /**
     * 
     * @type {string}
     * @memberof MlMetadataValue
     */
    int_value?: string;
    /**
     * 
     * @type {number}
     * @memberof MlMetadataValue
     */
    double_value?: number;
    /**
     * 
     * @type {string}
     * @memberof MlMetadataValue
     */
    string_value?: string;
}

/**
 * 
 * @export
 * @interface PathStep
 */
export interface PathStep {
    /**
     * 
     * @type {string}
     * @memberof PathStep
     */
    index?: string;
    /**
     * 
     * @type {string}
     * @memberof PathStep
     */
    key?: string;
}


/**
 * MetadataServiceApi - fetch parameter creator
 * @export
 */
export const MetadataServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary NOTE: The order of the following RPC methods affects the order of matching a particular HTTP path. So put a more specific path pattern before a generic one. For example, GET /api/v1alpha1/artifact_types/{parent}/artifacts should appear before GET /api/v1alpha1/artifact_types/{name} to be possibly matched.
         * @param {string} parent Creates the specified artifact as an instance of ArtifactType with this fully qualified name. |parent| takes the form &#x60;artifact_types/{namespace}/{name&gt;}&#x60;.
         * @param {MlMetadataArtifact} body The Artifact to create. Note that Artifact.type_id is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(parent: string, body: MlMetadataArtifact, options: any = {}): FetchArgs {
            // verify required parameter 'parent' is not null or undefined
            if (parent === null || parent === undefined) {
                throw new RequiredError('parent','Required parameter parent was null or undefined when calling createArtifact.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createArtifact.');
            }
            const localVarPath = `/api/v1alpha1/artifact_types/{parent}/artifacts`
                .replace(`{${"parent"}}`, encodeURIComponent(String(parent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MlMetadataArtifact" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MlMetadataArtifactType} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactType(body: MlMetadataArtifactType, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createArtifactType.');
            }
            const localVarPath = `/api/v1alpha1/artifact_types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MlMetadataArtifactType" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MlMetadataEvent} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(body: MlMetadataEvent, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createEvent.');
            }
            const localVarPath = `/api/v1alpha1/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MlMetadataEvent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} parent Creates the specified artifact as an instance of ExecutionType with this fully qualified name. |parent| takes the form &#x60;execution_types/{namespace}/{name&gt;}&#x60;.
         * @param {MlMetadataExecution} body The Execution to create. Note that Execution.type_id is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExecution(parent: string, body: MlMetadataExecution, options: any = {}): FetchArgs {
            // verify required parameter 'parent' is not null or undefined
            if (parent === null || parent === undefined) {
                throw new RequiredError('parent','Required parameter parent was null or undefined when calling createExecution.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createExecution.');
            }
            const localVarPath = `/api/v1alpha1/execution_types/{parent}/executions`
                .replace(`{${"parent"}}`, encodeURIComponent(String(parent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MlMetadataExecution" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MlMetadataExecutionType} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExecutionType(body: MlMetadataExecutionType, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createExecutionType.');
            }
            const localVarPath = `/api/v1alpha1/execution_types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MlMetadataExecutionType" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact(id: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteArtifact.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteArtifact.');
            }
            const localVarPath = `/api/v1alpha1/artifact_types/{name}/artifacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactType(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteArtifactType.');
            }
            const localVarPath = `/api/v1alpha1/artifact_types/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExecution(id: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteExecution.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteExecution.');
            }
            const localVarPath = `/api/v1alpha1/execution_types/{name}/executions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExecutionType(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteExecutionType.');
            }
            const localVarPath = `/api/v1alpha1/execution_types/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name Artifact name is like &#x60;artifact_types/{namespace}/{typename}/artifact/{id}&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifact(id: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getArtifact.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getArtifact.');
            }
            const localVarPath = `/api/v1alpha1/artifact_types/{name}/artifacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name ArtifactType names are of the form &#x60;artifact_types/{namespace}/{name}&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactType(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getArtifactType.');
            }
            const localVarPath = `/api/v1alpha1/artifact_types/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name Execution name is like &#x60;execution_types/{namespace}/{typename}/execution/{id}&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecution(id: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getExecution.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getExecution.');
            }
            const localVarPath = `/api/v1alpha1/execution_types/{name}/executions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionType(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getExecutionType.');
            }
            const localVarPath = `/api/v1alpha1/execution_types/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactTypes(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1alpha1/artifact_types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling listArtifacts.');
            }
            const localVarPath = `/api/v1alpha1/artifact_types/{name}/artifacts`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts2(name?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1alpha1/artifacts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List events based on an artifact or execution id.
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling listEvents.');
            }
            const localVarPath = `/api/v1alpha1/events/executions/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List events based on an artifact or execution id.
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents2(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling listEvents2.');
            }
            const localVarPath = `/api/v1alpha1/events/artifacts/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutionTypes(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1alpha1/execution_types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutions(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling listExecutions.');
            }
            const localVarPath = `/api/v1alpha1/execution_types/{name}/executions`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutions2(name?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1alpha1/executions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataServiceApi - functional programming interface
 * @export
 */
export const MetadataServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary NOTE: The order of the following RPC methods affects the order of matching a particular HTTP path. So put a more specific path pattern before a generic one. For example, GET /api/v1alpha1/artifact_types/{parent}/artifacts should appear before GET /api/v1alpha1/artifact_types/{name} to be possibly matched.
         * @param {string} parent Creates the specified artifact as an instance of ArtifactType with this fully qualified name. |parent| takes the form &#x60;artifact_types/{namespace}/{name&gt;}&#x60;.
         * @param {MlMetadataArtifact} body The Artifact to create. Note that Artifact.type_id is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(parent: string, body: MlMetadataArtifact, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCreateArtifactResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).createArtifact(parent, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {MlMetadataArtifactType} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactType(body: MlMetadataArtifactType, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCreateArtifactTypeResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).createArtifactType(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {MlMetadataEvent} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(body: MlMetadataEvent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).createEvent(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} parent Creates the specified artifact as an instance of ExecutionType with this fully qualified name. |parent| takes the form &#x60;execution_types/{namespace}/{name&gt;}&#x60;.
         * @param {MlMetadataExecution} body The Execution to create. Note that Execution.type_id is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExecution(parent: string, body: MlMetadataExecution, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCreateExecutionResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).createExecution(parent, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {MlMetadataExecutionType} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExecutionType(body: MlMetadataExecutionType, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCreateExecutionTypeResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).createExecutionType(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact(id: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).deleteArtifact(id, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactType(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).deleteArtifactType(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExecution(id: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).deleteExecution(id, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExecutionType(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).deleteExecutionType(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name Artifact name is like &#x60;artifact_types/{namespace}/{typename}/artifact/{id}&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifact(id: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiGetArtifactResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).getArtifact(id, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} name ArtifactType names are of the form &#x60;artifact_types/{namespace}/{name}&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactType(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiGetArtifactTypeResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).getArtifactType(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name Execution name is like &#x60;execution_types/{namespace}/{typename}/execution/{id}&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecution(id: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiGetExecutionResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).getExecution(id, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionType(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiGetExecutionTypeResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).getExecutionType(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactTypes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiListArtifactTypesResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).listArtifactTypes(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiListArtifactsResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).listArtifacts(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts2(name?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiListArtifactsResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).listArtifacts2(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List events based on an artifact or execution id.
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiListEventsResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).listEvents(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List events based on an artifact or execution id.
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents2(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiListEventsResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).listEvents2(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutionTypes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiListExecutionTypesResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).listExecutionTypes(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutions(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiListExecutionsResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).listExecutions(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutions2(name?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiListExecutionsResponse> {
            const localVarFetchArgs = MetadataServiceApiFetchParamCreator(configuration).listExecutions2(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MetadataServiceApi - factory interface
 * @export
 */
export const MetadataServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary NOTE: The order of the following RPC methods affects the order of matching a particular HTTP path. So put a more specific path pattern before a generic one. For example, GET /api/v1alpha1/artifact_types/{parent}/artifacts should appear before GET /api/v1alpha1/artifact_types/{name} to be possibly matched.
         * @param {string} parent Creates the specified artifact as an instance of ArtifactType with this fully qualified name. |parent| takes the form &#x60;artifact_types/{namespace}/{name&gt;}&#x60;.
         * @param {MlMetadataArtifact} body The Artifact to create. Note that Artifact.type_id is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(parent: string, body: MlMetadataArtifact, options?: any) {
            return MetadataServiceApiFp(configuration).createArtifact(parent, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {MlMetadataArtifactType} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactType(body: MlMetadataArtifactType, options?: any) {
            return MetadataServiceApiFp(configuration).createArtifactType(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {MlMetadataEvent} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(body: MlMetadataEvent, options?: any) {
            return MetadataServiceApiFp(configuration).createEvent(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} parent Creates the specified artifact as an instance of ExecutionType with this fully qualified name. |parent| takes the form &#x60;execution_types/{namespace}/{name&gt;}&#x60;.
         * @param {MlMetadataExecution} body The Execution to create. Note that Execution.type_id is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExecution(parent: string, body: MlMetadataExecution, options?: any) {
            return MetadataServiceApiFp(configuration).createExecution(parent, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {MlMetadataExecutionType} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExecutionType(body: MlMetadataExecutionType, options?: any) {
            return MetadataServiceApiFp(configuration).createExecutionType(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact(id: string, name: string, options?: any) {
            return MetadataServiceApiFp(configuration).deleteArtifact(id, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactType(name: string, options?: any) {
            return MetadataServiceApiFp(configuration).deleteArtifactType(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExecution(id: string, name: string, options?: any) {
            return MetadataServiceApiFp(configuration).deleteExecution(id, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExecutionType(name: string, options?: any) {
            return MetadataServiceApiFp(configuration).deleteExecutionType(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name Artifact name is like &#x60;artifact_types/{namespace}/{typename}/artifact/{id}&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifact(id: string, name: string, options?: any) {
            return MetadataServiceApiFp(configuration).getArtifact(id, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} name ArtifactType names are of the form &#x60;artifact_types/{namespace}/{name}&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactType(name: string, options?: any) {
            return MetadataServiceApiFp(configuration).getArtifactType(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name Execution name is like &#x60;execution_types/{namespace}/{typename}/execution/{id}&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecution(id: string, name: string, options?: any) {
            return MetadataServiceApiFp(configuration).getExecution(id, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionType(name: string, options?: any) {
            return MetadataServiceApiFp(configuration).getExecutionType(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactTypes(options?: any) {
            return MetadataServiceApiFp(configuration).listArtifactTypes(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts(name: string, options?: any) {
            return MetadataServiceApiFp(configuration).listArtifacts(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifacts2(name?: string, options?: any) {
            return MetadataServiceApiFp(configuration).listArtifacts2(name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List events based on an artifact or execution id.
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(name: string, options?: any) {
            return MetadataServiceApiFp(configuration).listEvents(name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List events based on an artifact or execution id.
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents2(name: string, options?: any) {
            return MetadataServiceApiFp(configuration).listEvents2(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutionTypes(options?: any) {
            return MetadataServiceApiFp(configuration).listExecutionTypes(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutions(name: string, options?: any) {
            return MetadataServiceApiFp(configuration).listExecutions(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExecutions2(name?: string, options?: any) {
            return MetadataServiceApiFp(configuration).listExecutions2(name, options)(fetch, basePath);
        },
    };
};

/**
 * MetadataServiceApi - object-oriented interface
 * @export
 * @class MetadataServiceApi
 * @extends {BaseAPI}
 */
export class MetadataServiceApi extends BaseAPI {
    /**
     * 
     * @summary NOTE: The order of the following RPC methods affects the order of matching a particular HTTP path. So put a more specific path pattern before a generic one. For example, GET /api/v1alpha1/artifact_types/{parent}/artifacts should appear before GET /api/v1alpha1/artifact_types/{name} to be possibly matched.
     * @param {string} parent Creates the specified artifact as an instance of ArtifactType with this fully qualified name. |parent| takes the form &#x60;artifact_types/{namespace}/{name&gt;}&#x60;.
     * @param {MlMetadataArtifact} body The Artifact to create. Note that Artifact.type_id is ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public createArtifact(parent: string, body: MlMetadataArtifact, options?: any) {
        return MetadataServiceApiFp(this.configuration).createArtifact(parent, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {MlMetadataArtifactType} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public createArtifactType(body: MlMetadataArtifactType, options?: any) {
        return MetadataServiceApiFp(this.configuration).createArtifactType(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {MlMetadataEvent} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public createEvent(body: MlMetadataEvent, options?: any) {
        return MetadataServiceApiFp(this.configuration).createEvent(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} parent Creates the specified artifact as an instance of ExecutionType with this fully qualified name. |parent| takes the form &#x60;execution_types/{namespace}/{name&gt;}&#x60;.
     * @param {MlMetadataExecution} body The Execution to create. Note that Execution.type_id is ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public createExecution(parent: string, body: MlMetadataExecution, options?: any) {
        return MetadataServiceApiFp(this.configuration).createExecution(parent, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {MlMetadataExecutionType} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public createExecutionType(body: MlMetadataExecutionType, options?: any) {
        return MetadataServiceApiFp(this.configuration).createExecutionType(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public deleteArtifact(id: string, name: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).deleteArtifact(id, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public deleteArtifactType(name: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).deleteArtifactType(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public deleteExecution(id: string, name: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).deleteExecution(id, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public deleteExecutionType(name: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).deleteExecutionType(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {string} name Artifact name is like &#x60;artifact_types/{namespace}/{typename}/artifact/{id}&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public getArtifact(id: string, name: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).getArtifact(id, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} name ArtifactType names are of the form &#x60;artifact_types/{namespace}/{name}&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public getArtifactType(name: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).getArtifactType(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {string} name Execution name is like &#x60;execution_types/{namespace}/{typename}/execution/{id}&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public getExecution(id: string, name: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).getExecution(id, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public getExecutionType(name: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).getExecutionType(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public listArtifactTypes(options?: any) {
        return MetadataServiceApiFp(this.configuration).listArtifactTypes(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public listArtifacts(name: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).listArtifacts(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public listArtifacts2(name?: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).listArtifacts2(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List events based on an artifact or execution id.
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public listEvents(name: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).listEvents(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List events based on an artifact or execution id.
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public listEvents2(name: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).listEvents2(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public listExecutionTypes(options?: any) {
        return MetadataServiceApiFp(this.configuration).listExecutionTypes(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public listExecutions(name: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).listExecutions(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataServiceApi
     */
    public listExecutions2(name?: string, options?: any) {
        return MetadataServiceApiFp(this.configuration).listExecutions2(name, options)(this.fetch, this.basePath);
    }

}

